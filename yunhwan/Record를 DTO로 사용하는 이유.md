## Record를 DTO로 사용하는 이유는?
- Record는 Java 16에서 정식으로 출시된 특별한 유형의 클래스로 불변성(Immmutable)을 기본으로 함
- 기존의 클래스와 달리 모든 필드가 final로 선언되며 객체 생성 후 변경할 수 없음
- 필드 선언만으로 자동으로 생성자, getter, equals(), hashCode(), toString() 등 메서드를 자동으로 생성해주어 보일러 플레이트 코드를 줄일 수 있음
- 멀티 스레드 환경에서 데이터가 의도치 않게 변경되지 않고 안전하게 전달할 수 있음
```java
public record MemberDto(String name, String email, int age){}
```

### 그럼 Record로 생성한 모든 객체는 DTO인가?
- DTO, VO부터 간단하게 정리
  - DTO (Data Transfer Object)
    - 계층 간 데이터 전달만을 위한 객체
    - 컨트롤러 <-> 서비스, 서비스 <-> DAO 사이에서 데이터를 담아 전달
    - 주로 단순한 필드 집합
    - 비즈니스 로직은 포함하지 않음
  - VO (Value Object)
    - 도메인 모델 내에서 "값"을 표현하는 객체
    - 동일성을 값으로 판단 (equals, hashCode)
    - 불변이어야 함 (값이 변하면 새로운 객체 생성)
    - 도메인 로직(값과 관련된 검증, 계산 등)을 가질 수 있음

- 모든 Record 객체가 DTO인 것은 아님
- Record는 단순히 데이터를 캡슐화하는 역할을 하는데, DTO 외에도 값 객체(Value Objects) 등의 다양한 용도로 사용될 수 있음
```java
public record Coordinates(double x, double y){}
```
- DTO는 계층 간 데이터 전송을 목적으로 하는 객체
- VO는 도메인 모델 내에서 특정 값을 표현하는 객체로 사용
- Record는 이 두 가지 모두에 적합하게 사용할 수 있지만, 그 목적에 따라 사용 방법이 달라짐
- **정리**
  - **Record로 생성한 모든 객체가 DTO는 아닙니다. Record는 단순 불변 데이터를 표현하기 위한 문법적 도구이고 DTO처럼 계층 간 데이터 전달에 사용할 수도 있고, VO처럼 도메인 모델 내에서 특정 값을 표현하는데도 사용할 수 있습니다. 결국 Record는 DTO인지 VO인지를 결정하는 것이 아니라 사용하는 목적에 따라 달라집니다.**

### Record와 VO를 비교?
- Record와 VO 모두 객체의 상태가 변경되지 않는 것을 보장
- 데이터를 캡슐화하여 표현하는 데 초첨을 맞춤
- VO는 값 기반의 동등성, Record도 동일한 필드 값을 가지면 동일한 객체로 간주된다는 공통점
- VO
  - 도메인 모델 내에서 특정 개념을 표현하고, 도메인 로직과 밀접하게 관련이 있음
  - 비즈니스 로직이나 규칙을 가질 수 있음
- Record
  - 단순히 데이터를 캡슐화하여 전달하는데 의미가 있음
- **정리**
  - **Record와 VO는 모두 불변성을 가지며 값 기반 동등성을 지원한다는 공통점이 있습니다. 하지만, Record는 단순히 데이터를 담는 언어 차원의 문법적 도구이고, VO는 도메인 모델 내에서 특정 값을 의미 있게 표현하여 검증이나 계산 같은 도메인 로직을 가질 수 있습니다. 따라서, Record는 VO를 구현하는데 적합한 도구이지만, VO의 개념 자체를 대체하지는 않습니다.**

### Record의 한계는?
- Record는 extends를 사용하여 다른 클래스를 상속할 수 없고 필드가 final로 선언되기 때문에 확장이 어려움
- 주로 데이터를 전달하려는 목적으로 설계되었기 때문에 비즈니스 로직을 포함하기에 적절하지 않음
- Java 14 또는 16 이전 버전에서 호환이 불가능하다는 점이 있음 
  